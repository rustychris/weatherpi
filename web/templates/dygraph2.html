<html>
  <head>
    <script type="text/javascript"
            src="{{ url_for('static',filename='dygraph-combined.js') }}"></script>
    <script type="text/javascript" src="{{ url_for('static',filename='synchronizer.js') }}"></script>
    <script type="text/javascript" src="{{ url_for('static',filename='interaction-api.js') }}"></script>
    <style>
    .graph_panel {
        height: 45%; /* 200px; */
        width: 90%; /* 500px; */
    }
    </style>
  </head>
  <body>
    <div id="graph_temp" class="graph_panel">
      Temp
    </div>
<!--    <div id="graph_light" class="graph_panel">
      Light
    </div>
    <div id="graph_pressure" class="graph_panel">
      Pressure
    </div>
-->
<!--      <p> Start time: {{ data_start_time }}
     <p> Stop time:  {{ data_stop_time }} -->
    <script type="text/javascript">
// distinguish between the date range of the data, and of the displayed
// graph.
// Parsing dates this way is apparently discouraged due to browser inconsistencies
var data_range_time=[new Date(1000*{{ data_start_time }}),
                     new Date(1000*{{ data_stop_time }})];

var data_range_tstamp=[data_range_time[0].getTime(),
                       data_range_time[1].getTime()];
var data_res=0;
// trying to be ... /data/rockridge/get?start=
var csv_url="{{ url_for("fetch",stream="rockridge") }}?start="+ data_range_time[0].toISOString() +
    "&stop=" + data_range_time[1].toISOString() + "&res="+data_res;
var view_range_tstamp;

console.log("CSV URL: " + csv_url);

function update_data(dg,new_range_tstamp,res) {
    // record the change before waiting for it to actually happen:
    data_range_tstamp=new_range_tstamp;
    data_res=res;
        
    var start_time=new Date() ; start_time.setTime(data_range_tstamp[0]);
    var stop_time= new Date() ;  stop_time.setTime(data_range_tstamp[1]);
    
    var new_csv_url="{{ url_for("fetch",stream="rockridge") }}?start="+ start_time.toISOString() +
        "&stop=" + stop_time.toISOString() + "&res=" + res;
    console.log("About to update opts for " + dg);

    var vis=[false,false,false,true,false];

    // the max/min code is disabled for now both here and in fetch on the
    // python side.
    
    // if( res>0 ) {
    //     vis=[false,false,false,
    //          false,false,false,
    //          false,false,false,
    //          false,true,false,
    //          false,false,false];
    // }
    
    dg.updateOptions({'file':new_csv_url,
                      'visibility':vis});
    console.log('draw: ' + new_csv_url);
}



function handle_draw(dg,is_initial) {
    if ( is_initial ) {
        console.log('handle_draw: skipping initial');
        return;
    }
    
    view_range_tstamp=dg.xAxisRange();
    // these are javascript timestamps - like unix epoch but
    // but in milliseconds

    var delta=view_range_tstamp[1] - view_range_tstamp[0];
    
    var wide_range=[ view_range_tstamp[0] - 0.5*delta,
                     view_range_tstamp[1] + 0.5*delta];
    
    // are we still at the right resolution of the data?
    if ( (data_res<3600) && (delta > 86400 * 1000) ) {
        console.log("Switch to hourly");	 
        update_data(dg,wide_range,3600);
        return;
    }
    if ( (data_res>0) && (delta<86400*1000) ) {
        console.log("Switch to full res");					   
        update_data(dg,wide_range,0);
        return;
    }

    // check the overlap - decide whether to update data.
    // this is reasonably snappy locally...
    
    if ( (data_range_tstamp[0] > view_range_tstamp[0]) ||
         (data_range_tstamp[1] < view_range_tstamp[1]) ) {
        console.log("Update range");        
        // request something wider than the current view to offer
        // some amount of buffer for further zoom/pan.
        update_data(dg,wide_range,data_res);
    }
}

// this is a bit nicer on laptop, but breaks the phone interaction
var interactions= {
    'mousedown' : downV3,
    'mousemove' : moveV3,
    'mouseup' : upV3,
    'click' : clickV3,
    'dblclick' : dblClickV3,
    'mousewheel' : scrollV3
};

function axis_fmt_date(d,gran) {
    //console.log("Gran: "+gran);
    if ( gran < Dygraph.DAILY ) {
	return d.toLocaleTimeString('en-US',
				    {'hour':'numeric','minute':'numeric'});
    } else {
	return d.toLocaleDateString();
    }

}
function value_fmt_date(ms,gran) {
    let d=new Date(ms);
    return d.toLocaleString();    
}

var g1 = new Dygraph(document.getElementById("graph_temp"),
                     csv_url,
		     {
			 axes: {
			     x: {
				 axisLabelFormatter:axis_fmt_date,
				 valueLabelFormatter:value_fmt_date,
			     }
			 },
                         'visibility':[false,false,false,true,false],
			 'drawCallback':handle_draw,
			 strokeWidth:3,
			 labelsUTC: false,
			 axisLabelFontSize:20,
  //                       interactionModel : interactions
                     });

if ( 0 ) {
    var g2 = new Dygraph(document.getElementById("graph_light"),
                         csv_url,
                         {
                             'visibility':[false,true,false,false,false]
                         });
    var g3 = new Dygraph(document.getElementById("graph_pressure"),
                         csv_url,
                         {
                             'visibility':[false,false,true,false,false]
                         });
    var sync=Dygraph.synchronize(g1,g2,g3, {'range':false});
}

</script>
    
</body>
</html>
